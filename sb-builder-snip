#!/usr/bin/env node

var program  = require('commander');
var config   = require('./lib/config').config;
var manifest = require('./lib/manifest').read();
var sprintf  = require("sprintf-js").sprintf;
var async    = require('async');
var fs       = require('fs-extra');
var spawn    = require('child_process').spawn;
var avconv   = require('avconv');
var mp3info  = require('mp3info');
var readline = require('readline');
var log      = require('./lib/log').log('sb-builder');

program
    .option('-f, --from <n>',     'Sound snippet start time')
    .option('-t, --to <n>',       'Sound snippet end time')
    .option('-d, --duration <n>', 'Sound snippet duration (alternative to --to)')
    .parse(process.argv);

if(program.args.length !== 1){
    log.info('Usage: sb-builder snip [options] <ID>');
    process.exit();
}

var info = _snip_handle_arguments(program.args[0]);

if(! info.id in manifest.sources){
    return next({
        error: 'no_such_video',
        no_such_video: 'Video with ID '+id+' has not been downloaded yet!'
    });
}
var snipData = {};
snipData.id       = sprintf("%06d",+Object.keys(manifest.sounds).length+1);
snipData.sourceID = info.id;
snipData.paths    = {
    tmp: config.tmpPath   +'/'+snipData.id+'.mp3',
    mp3: config.soundsPath+'/'+snipData.id+'.mp3',
    ogg: config.soundsPath+'/'+snipData.id+'.ogg'
};

var srcPath = manifest.sources[info.id].path;

async.waterfall([
    // Create sound snippet file
    function(next){
        var timeOpts = _handleTimeOpts(srcPath, program);
        snipData.startsAt = timeOpts.from || null;
        log.info("Extracting snippet from original source '"+snipData.sourceID+"' ...");
        roughCutSnippet(srcPath, snipData.paths.tmp, timeOpts, next);
    },
    // Open in external sound editing app
    function(next){
        log.info('Opening sound snippet in external app ...');
        var soundEditApp = spawn(config.soundEditCommand, [snipData.paths.tmp]);
        soundEditApp.on('close', next);
    },
    // Get sound snippet metadata
    function(res, next){
        log.info('Getting snippet metadata ...');
        mp3info(snipData.paths.tmp, function(err, info){
            if(err){
                log.error('Error extracting snippet info:',err);
                return next(err);
            }
            return next(null, info.length);
        });
    },
    // Get snippet transcription/description
    function(length,next){
        snipData.length = length;
        var rl = readline.createInterface({
            input  : process.stdin,
            output : process.stdout
        });
        rl.question('Sound snippet transcription/description:\n> ', function(text){
            snipData.text = text;
            return next();
        });
    },
    // Generate .ogg version of snippet
    function(next){
        log.info('Generating OGG version ...');
        convertMP3toOGG(snipData.paths, {}, next);
    },
    // Move .mp3 from temp folder to final path
    function(next){
        log.info('Moving MP3 version to final path ...');
        var tmpPath = snipData.paths.tmp;
        var finalPath = snipData.paths.mp3;
        fs.rename(tmpPath, finalPath, next);
    }],
    function(err){
        if(err){
            log.error('Error getting sound snippet:', err);
            return;
        }
        snipData.dateAdded = new Date().toISOString();
        delete snipData.paths.tmp;
        manifest.writeSound(snipData);
        log.info('Finished!');
        process.exit();
    }
);

function _handleTimeOpts(srcPath, program){
    var timeOpts = {};
    timeOpts.from = +program.from || 0 ;
    if(program.duration){ timeOpts.duration = +program.duration; }
    else {
        if(program.to){
            timeOpts.duration = +program.to-timeOpts.from;
            if(timeOpts.duration < 0){
                log.warn("Sound snippet duration can't be < 0 ("+timeOpts.duration+"), using default ...");
                timeOpts.duration = 30;
            }
        }
        else { timeOpts.duration = 30; }
    }
    return timeOpts;
}

function convertMP3toOGG(paths, options, callback){
    var stream = avconv([
        '-i'     , 'pipe:0' , // read from stdin
        '-vn'    ,
        '-acodec', 'libvorbis',
        '-ac'    , 2        , // channels
        '-ab'    , '160k'   , // bitrate
        '-ar'    , 48000    , // dont even know
        '-f'     , 'ogg'    , // output format
        'pipe:1'              // write to stdout
    ]);

    stream.once('exit', function(exitCode) {
        return callback(exitCode?exitcode : null);
    });
    stream.on('error', function(err) {
        log.error('Error generating .ogg version of snippet', err.stack);
        throw err;
    });
    fs.createReadStream(paths.tmp).pipe(stream);
    stream.pipe(fs.createWriteStream(paths.ogg));
}

function roughCutSnippet(srcPath, dstPath, options, callback){
    if(typeof options.from !== 'undefined'){
        var from = options.from;
        var duration = options.duration || (options.to ? (+options.to-options.from) : null) || 30;
        var stream = avconv([
            '-i'     , 'pipe:0' , // read from stdin
            '-ss'    , from     , // start time
            '-t'     , duration , // duration
            '-ab'    , '160k'   , // bitrate
            '-ac'    , 2        , // channels
            '-ar'    , 44100    , // dont even know
            '-f'     , 'mp3'    , // output format
            'pipe:1'              // write to stdout
        ]);

        // Readable stream exits sooner than expecting due to
        // avconv -t param
        process.on('uncaughtException', function (err) {
            if(err.code !== 'ECONNRESET'){
                log.error(err);
                throw err;
            }
        });
        stream.once('exit', function(exitCode) {
            return callback(exitCode?exitcode : null);
        });
        stream.on('error', function(err) {
            log.error('Error cutting snippet', err.stack);
            throw err;
        });
        fs.createReadStream(srcPath).pipe(stream);
        stream.pipe(fs.createWriteStream(dstPath));
    } else { return fs.copy(srcPath, dstPath, callback); }
}

function _snip_handle_arguments(){
    var id, t, url;

    if(arguments[0].match(/youtube\.com/)){
        var urlInfo = URL.parse(arguments[0]);
        var params = qs.parse(urlInfo.query);
        id = params.v;
        t = params.t;
    } else if(arguments[0].match(/youtu\.be/)){
        var urlInfo = URL.parse(arguments[0]);
        var params = qs.parse(urlInfo.query);
        urlInfo.pathname.match(/^\/(\w+)$/);
        id = RegExp.$1
        t = params.t;
    }
    else { id = arguments[0]; }
    var info = {};
    if(t){ info.t = t; }
    info.id = id;
    return info;
}
